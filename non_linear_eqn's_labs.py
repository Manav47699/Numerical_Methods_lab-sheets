# -*- coding: utf-8 -*-
"""Non_linear_eqn's_labs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G1umWbTh4Ejzi-4H7owuQvGNyZS6MqyY

# This file contains finding root for non-linear eqn by:

1.   Bisection Method
2.   Regula-Falsi Method
3.   Secant Method
4.   Newton-Raphson Method

# Bisection Method
"""

# Bisection method (cleaned up version)
import math
import numpy as np

eqn = input("Enter the equation in python syntax: ")

def F(x, eqn):
    return eval(eqn, {"x": x, "exp": np.exp})

def f(x):
    return F(x, eqn)

a = float(input("Enter the first initial guess: "))
b = float(input("Enter the second initial guess: "))
m = []

if f(a) * f(b) > 0:
    print(f"No root lies in the interval ({a}, {b})")

else:
    e = float(input("Enter the tolerable error: "))
    N = int(input("Enter the maximum number of iterations: "))
    i = 1

    while i <= N:
        c = (a + b) / 2
        m.append(c)
        fc = f(c)

        print(f"Iteration {i}: a = {a:.5f}, b = {b:.5f}, c = {c:.5f}, f(c) = {fc:.5f}")

        if f(a) * fc < 0:
            b = c
        else:
            a = c

        error = abs(b - a)
        if error < e:
            print(f"\n✅ Approximate root = {(a + b)/2:.5f} found in {i} iterations (tolerance: {e})")
            break

        i += 1

    if i > N:
        print(f"\n❌ Maximum iterations ({N}) reached. Solution may not have converged.")


import numpy as np
import matplotlib.pyplot as plt

# The 'm' list should already be populated from your bisection method logic.
# Ensure 'a' and 'b' are also defined from previous steps.

# Convert m to a NumPy array here, if it's still a list from the bisection loop.
# This should be the only 'm = np.array(m)' line in this block.
m = np.array(m)            #converts the variable m (a list) into a NumPy array.




x = np.linspace(0, 1, 1000)     #creates a numpy array "x" with 1000 values (0.001.......0.999). We put 1000 as our tolorable error is 0.001

plt.figure(figsize=(10, 6))
plt.plot(x, f(x), color='red', label=eqn)      #Plots the graph of the function f(x) against the values in the array x.
#label=eqn is for the legend() below
plt.axhline(0, color='black') # Simplified from (0,0)
plt.axvline(0, color='black') # Simplified from (0,0)
plt.legend()        #used to show that small box on the bottom right corner
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid(True)
plt.title('Bisection Method')
plt.scatter(m, f(m))

for i, val in enumerate(m):                        #index ->> i
    plt.text(val, f(val) + 0.05, f'{i+1}')          #(x-axis, y-axis, which number to display)

plt.show()

"""# Regula-Falsi (False position) method"""

import math  # Needed for math functions like sin, exp, etc.
import numpy as np

# Input the equation
eqn = input("Enter the equation in python syntax (use 'x' as variable): ")

# Function to evaluate f(x)
def F(x, eqn):
    return eval(eqn, {"x": x, "exp": np.exp})

def f(x):
    return F(x, eqn)

# Initial guesses
a = float(input("Enter the first initial guess (a): "))
b = float(input("Enter the second initial guess (b): "))
n = []

# Check if root exists in interval
if f(a) * f(b) > 0:
    print(f"❌ No root lies in the interval ({a}, {b})")
else:
    e = float(input("Enter the tolerable error: "))
    N = int(input("Enter the maximum number of iterations: "))

    print("\n{:<10} {:<12} {:<12} {:<12} {:<12} {:<12}".format(
      "Iteration", "a", "b", "f(a)", "f(b)", "c"))
    print("-" * 70)

    i = 1
    while i <= N:
        fa = f(a)
        fb = f(b)
        c = (a * fb - b * fa) / (fb - fa)
        n.append(c)
        fc = f(c)

        print("{:<10} {:<12.5f} {:<12.5f} {:<12.5f} {:<12.5f} {:<12.5f}".format(
            i, a, b, fa, fb, c))

        if abs(fc) < e:
            print(f"\n✅ Approximate root = {c:.5f} found in {i} iterations (tolerance: {e})")
            break

        if fa * fc < 0:
            b = c
        else:
            a = c

        i += 1

    if i > N:
        print(f"\n❌ Maximum iterations ({N}) reached. Solution may not have converged.")
import numpy as np
import matplotlib.pyplot as plt

# The 'n' list should already be populated from your Regula Falsi method logic.
# Ensure 'a' and 'b' are also defined from previous steps.

# Convert n to a NumPy array here, if it's still a list from the Regula Falsi loop.
# This should be the only 'n = np.array(n)' line in this block.

n = np.array(n)

x = np.linspace(0, 1, 1000)
plt.figure(figsize=(10, 6))
plt.plot(x, f(x), color='red', label=eqn)
plt.axhline(0, color='black')
plt.axvline(0, color='black')
plt.legend()
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid(True)
plt.title('Regula Falsi Method')  # Changed title to Regula Falsi
if n.size > 0: # Only attempt to scatter plot if 'n' has data
    plt.scatter(n, f(n)) # Removed color and zorder for simplicity
    for i, val in enumerate(n):
        plt.text(val, f(val) + 0.05, f'{i+1}') # Fixed offset, no bbox or dynamic calculation

plt.show()

"""# Secant Method"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Input the equation: use numpy functions like exp(x), sin(x), etc.
eqn = input("Enter the equation (use numpy functions like exp(x), sin(x)): ")

# Define f(x) to support both scalar and numpy array inputs using numpy functions
def f(x):

        #'sin': np.sin,
        #'cos': np.cos,
        #'log': np.log,
       # 'sqrt': np.sqrt,
        # add more numpy functions if needed

    return eval(eqn, {
        'x': x,
        'exp': np.exp,})

# Get initial guesses
a = float(input("Enter the first guess: "))
b = float(input("Enter the second guess: "))

A = []  # to store iteration info
m = []  # to store roots approximations

if f(a) == f(b):
    print("Value becomes infinite. Choose another guess.")
else:
    e = float(input("Enter the error tolerance: "))
    N = int(input("Enter the number of iterations: "))
    itr = 1
    while itr <= N:
        fa = f(a)
        fb = f(b)
        c = (a * fb - b * fa) / (fb - fa)
        fc = f(c)
        m.append(c)
        A.append([itr, a, b, c, fa, fb, fc])
        err = abs(fc)
        if err < e:
            df = pd.DataFrame(A, columns=['itr', 'a', 'b', 'c', 'f(a)', 'f(b)', 'f(c)'])
            print(df.to_string(index=False))
            print(f"The root of the equation is: {c} in {itr} iterations")
            break
        a, b = b, c
        itr += 1
    if itr > N:
        print("Root did not converge in the given iterations")

# Plotting
m = np.array(m)

x = np.linspace(-5, +5, 2000)  # Range centered around root guesses

plt.figure(figsize=(10, 6))
plt.plot(x, f(x), label=eqn, color='red')
plt.axhline(0, color='black')
plt.axvline(0, color='black')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Secant Method Root Finding')
plt.grid(True)
plt.legend()

plt.scatter(m, f(m), color='blue')

for i, val in enumerate(m):
    plt.text(val, f(val) + 0.05, f'{i+1}')  # slightly above each point

plt.show()

"""# Newton Raphson Method"""

#NEWTON RAPHSON METHOD
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Input equation using numpy syntax (e.g. exp(x), sin(x))
eqn = input("Enter the equation (use numpy functions like exp(x), sin(x)): ")

# Function to evaluate f(x) safely with numpy functions
def f(x):

        #'sin': np.sin,
        #'cos': np.cos,
        #'log': np.log,
       # 'sqrt': np.sqrt,
        # add more numpy functions if needed

    return eval(eqn, {
        'x': x,
        'exp': np.exp,})

# Numerical derivative (central difference)
def g(f, x, h=1e-10):
    return (f(x + h) - f(x - h)) / (2 * h)

A = []  # to store iteration data
m = []  # to store root approximations for plotting

a = float(input("Enter the initial guess: "))

if g(f, a) == 0:
    print("First derivative of the function at initial guess is zero. Try a different guess.")
else:
    e = float(input("Enter the error tolerance: "))
    N = int(input("Enter the maximum number of iterations: "))
    itr = 1
    while itr <= N:
        fa = f(a)
        ga = g(f, a)
        if ga == 0:
            print("Zero derivative encountered during iterations. Stopping.")
            break
        b = a - fa / ga
        A.append([itr, a, fa, ga, b])
        m.append(b)
        err = abs(f(b))

        if err < e:
            df = pd.DataFrame(A, columns=['Iteration', 'a', 'f(a)', "g(a)", 'b'])
            print( df.to_string(index=False))
            print(f"\nThe root of the equation is approximately: {b} in {itr} iterations")
            break
        a = b
        itr += 1
    else:
        print("Root did not converge within the given iterations.")

# Plotting
m = np.array(m)

x = np.linspace(min(m) - 5, max(m) + 5, 2000)

plt.figure(figsize=(10, 6))
plt.plot(x, f(x), label=eqn, color='purple')
plt.axhline(0, color='black')
plt.axvline(0, color='black')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Newton-Raphson Method Root Finding')
plt.grid(True)
plt.legend()

plt.scatter(m, f(m), color='blue')

for i, val in enumerate(m):
    plt.text(val, f(val) + 0.05, f'{i+1}')

plt.show()